## 参考资料
1. https://kaisery.github.io/trpl-zh-cn/ch03-02-data-types.html
## 常见编程概念
### 变量与可变性
1. 变量：rust中定义的变量默认是不可修改的，如果需要修改，则需要使用mut关键字
```rust
let x = 5;
x = 6; // 报错
let mut x = 5;
x = 6; // 不报错
```
2. 常量：常量使用const关键字定义，**常量必须在定义时指定类型**，且不能使用mut关键字。在声明它的作用域中，常量在整个程序生命周期中都是有效的
```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```
3. 隐藏：隐藏是指使用同样的变量名来覆盖之前定义的变量，隐藏与变量不可修改不同，隐藏的变量可以覆盖，且新变量类型必须与之前定义的变量类型相同
```rust
let x = 5;
let x = x + 1;
```
### 数据类型
1. <font color=red>补码</font>：正数和0的补码就是其本身。负数的补码是将其**绝对值**按位取反再加1. 负数将补码翻译成原码，需要再取反加1.
2. 使用“--release” flag在release模式中构建时，Rust不会检测会导致panic的整型溢出。相反发生整型溢出的时候，Rust会进行一种被称为二进制补码Wrapping的操作，即回绕。可以使用以下几类标准库提供的原始数字类型方法显示的处理溢出的可能性
    * 所有模式下都可以使用“wrapping_*”方法进行wrapping，如wrapping_add
    * 如果“checked_*"”方法出现溢出，则返回None值
    * 用“overflowing_*”方法返回值和一个布尔值，表示是否出现溢出
    * 用“saturating_*”方法在值的最小值或最大值处进行饱和处理
3.  Rust中使用单引号声明char字面量，使用双引号声明字符串字面量。char类型的大小为四个字节，并代表一个unicode标量值。因此Rust的char类型可以表示很多字符甚至是表情符号
4. Rust有两个原生的复合类型：元组(tuple)和数组(array)
    * 元组是将一个或多个类型的值组合进一个复合类型的方式。<font color=red>元组长度固定，一旦声明，其长度不会增大或缩小</font>。使用包含在圆括号中的逗号分隔的值列表来创建一个元组。
        ```rust
        fn main() {
            let x : (i32, f64, u8) = (500, 5.4, 1);
            let tup = (500, 6.4, 1); //两种定义方式都可以
            let (x, y, z) = tup; //解构元组
            let one = tup.0; //可以使用“.”后跟索引值直接访问元素
        }
        ```
    **不带任何值的元组称为单元元组， 写作“(),通常表示空值或空的返回类型。<font color=red>如果表达式不返回任何类型的值，则会隐式的返回单元值</font>**
    * 数组类型，与元组的区别在于每个元素的类型必须相同。将数组的值写在方括号中(与c++不同)，使用逗号分隔。<font color=red>数组所申请的内存在栈上，vector申请的内存在堆上</font>。
        ```rust
        fn main() {
            let a = [1,2,3,4,5];
            let a:[i32; 5] = [1,2,3,4,5];//在方括号中包含元素类型，后跟分号，再后跟数组元素的数量
            let a = [3;5];//通过在方括号中指定初始值加分号再加元素个数的方式来创建一个每个元素都相同的数组
            let one = a[0];
        }
        ```
    ***<font color=red>疑问：<font> 1. 元组和数组中， 访问元素，将元素值赋值给了其他变量，期间所有权是否发生转移？   2. rust中没有map和set等原生的复合类型？***

### 函数
1. Rust不关心函数定义所在位置，只要函数被调用时出现在调用处可见的作用域内就行(与c/c++不同)。<font color=red>那么Rust编译器在编译代码的时候的行为是怎么样的呢，如何保证的这一特性？</font>