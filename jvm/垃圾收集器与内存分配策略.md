* 哪些内存要回收？
* 什么时候回收？
* 如何回收？

**java虚拟机中的 程序计数器，虚拟机栈， 本地方法栈这三个区域随线程的产生而产生，随线程的消亡而消亡，因此这几个区域内存的分配回收具有确定性**。<font color = red> 而java的堆和方法区这两个区域有着很明显的不确定性， 这便是垃圾收集器所关注的区域</font>
## 对象死亡判断
如何判断一个对象是否死亡呢？
1. 引用计数器，在对象创建时添加一个引用计数器，当有人引用时，计数器+1，引用接解除时计数器-1.当计数器减为0时，则释放对象
    
    优点：效率高
    
    缺点：在比较复杂的情况下，需要大量的额外处理保证引用的正确。比如对象之间的循环引用问题
    ```
    public class ReferenceCountingGC {

        public Object instance = null;

        private static final int _1MB = 1024 * 1024;

        /*这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过 */

        private byte[] bigSize = new byte[2 * _1MB];

        public static void testGC() {

            ReferenceCountingGC objA = new ReferenceCountingGC();
            ReferenceCountingGC objB = new ReferenceCountingGC();
            objA.instance = objB;
            objB.instance = objA;

            objA = null;
            objB = null;

            // 假设在这行发生GC，objA和objB是否能被回收
            System.gc();
        }

    }
    ```
2. 可达性分析算法

    java虚拟机就是根据可达性分析算法来判断对象是否还存活。这个算法的基本思路是通过一系列称为“GC Roots”的根对象作为起始节点集向下开始搜索。如果一个对象和GC Roots间没有任何引用链接，那么此对象将被认定为不再被使用
    ![Alt text](images/image2.png)

    **GC Roots的对象包括以下几种**
    
    * 在虚拟机栈中引用的对象，如各个县城的方法栈中使用到的参数，局部变量，临时变量
    * 在方法区中静态属性引用的对象，如java类的引用类静态变量 <font color = red>? </font>
    * 在方法区中常量引用的对象，如字符串常量池例的引用
    * 在本地方法栈中JNI(Native方法)引用的对象<font color = red>? </font>
    * Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象(如NullPointException, OutOfMemoryError等)，还有系统类加载器
    * 所有被同步锁(synchronized关键字)持有的对象
    * 反映Java虚拟机内部情况的JNXBean，JVNTI中注册的毁掉，本地代码缓存等<font color = red>? </font>

    **关于引用**

    强引用，软引用，弱引用和虚引用，引用强度一次递减

    * 强引用是最传统的“引用”定义，指在程序代码中普遍存在的引用赋值("Object obj = new Object()") 只要强引用关系还存在，垃圾收集器就永远不会收掉被引用的对象